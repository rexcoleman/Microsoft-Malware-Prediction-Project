import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def handle_missing_values(df, strategy='mean'):
    """
    Handle missing values in the dataframe.

    Parameters:
    - df (DataFrame): input dataframe with potential missing values.
    - strategy (str): strategy for handling missing values ('mean', 'median', 'mode').

    Returns:
    - DataFrame: dataframe with missing values handled.
    """
    for column in df.columns:
        if df[column].dtype in [np.float64, np.float32, np.int64, np.int32]:
            if strategy == 'mean':
                df[column].fillna(df[column].mean(), inplace=True)
            elif strategy == 'median':
                df[column].fillna(df[column].median(), inplace=True)
        elif df[column].dtype == 'category':
            df[column].fillna(df[column].mode()[0], inplace=True)
    return df

def remove_duplicates(df, id_column):
    """
    Remove duplicate rows based on a specified column.
    
    Parameters:
    - df: DataFrame, input data.
    - id_column: str, column to check for duplicates.
    
    Returns:
    - DataFrame: data with duplicates removed.
    """
    df = df.drop_duplicates(subset=[id_column])
    return df

def check_no_missing_values(df):
    """
    Check if there are no missing values in the dataframe.

    Parameters:
    - df (DataFrame): input dataframe.

    Returns:
    - bool: True if no missing values, else False.
    """
    return not df.isnull().values.any()

def check_no_duplicates(df, id_column):
    """
    Check if there are no duplicate rows based on a specified column.

    Parameters:
    - df (DataFrame): input dataframe.
    - id_column (str): column to check for duplicates.

    Returns:
    - bool: True if no duplicates, else False.
    """
    return df.duplicated(subset=[id_column]).sum() == 0

def analyze_missing_values(df):
    """
    Analyze the missing values in the dataframe.

    Parameters:
    - df (DataFrame): input dataframe.

    Returns:
    - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
    """
    missing_values = df.isnull().sum()
    missing_percentage = (missing_values / len(df)) * 100
    missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
    return missing_data.sort_values(by='missing_count', ascending=False)

def compute_correlations(df, target_column):
    """
    Compute the correlation of features with the target variable.

    Parameters:
    - df (DataFrame): input dataframe.
    - target_column (str): the target variable.

    Returns:
    - DataFrame: a dataframe containing the correlation of each feature with the target variable.
    """
    numeric_df = df.select_dtypes(include=[np.number])
    if target_column not in numeric_df.columns:
        raise KeyError(f"Target column '{target_column}' not found in the dataframe.")
    correlations = numeric_df.corr()[target_column].sort_values(ascending=False)
    return correlations

def visualize_distributions(df, features):
    """
    Visualize the distributions of specified features.

    Parameters:
    - df (DataFrame): input dataframe.
    - features (list): list of feature names to visualize.
    """
    for feature in features:
        plt.figure(figsize=(10, 6))
        sns.histplot(df[feature].replace([np.inf, -np.inf], np.nan), kde=True)
        plt.title(f'Distribution of {feature}')
        plt.show()

def feature_summary(df):
    """
    Generate summary statistics for features.

    Parameters:
    - df (DataFrame): input dataframe.

    Returns:
    - DataFrame: summary statistics for features.
    """
    summary = df.describe(include='all').transpose()
    return summary

def visualize_pairwise_relationships(df, features):
    """
    Visualize pairwise relationships between specified features.

    Parameters:
    - df (DataFrame): input dataframe.
    - features (list): list of feature names to visualize.
    """
    sns.pairplot(df[features])
    plt.show()

def analyze_unbalanced_features(df, target_column):
    """
    Analyze unbalanced features in relation to the target variable.

    Parameters:
    - df (DataFrame): input dataframe.
    - target_column (str): the target variable.
    """
    unbalanced_features = {}
    for column in df.columns:
        if df[column].dtype == 'category' or df[column].nunique() <= 10:
            unbalanced_features[column] = df[column].value_counts(normalize=True)
    for feature, distribution in unbalanced_features.items():
        plt.figure(figsize=(10, 6))
        distribution.plot(kind='bar')
        plt.title(f'Distribution of {feature}')
        plt.show()

def convert_mixed_types(df, dtypes):
    """
    Convert mixed types to specified dtypes.
    
    Parameters:
    - df (DataFrame): input dataframe.
    - dtypes (dict): dictionary of column dtypes.
    
    Returns:
    - DataFrame: DataFrame with converted dtypes.
    """
    for column, dtype in dtypes.items():
        try:
            if dtype == 'category':
                df[column] = df[column].astype('category')
            else:
                df[column] = pd.to_numeric(df[column], errors='coerce').astype(dtype)
        except ValueError:
            print(f"Warning: Could not convert column {column} to {dtype}. Problematic values: {df[column].unique()[:5]}")
    return df

def clean_numeric_columns(df, columns):
    """
    Clean columns that should be numeric by removing or converting non-numeric values.
    
    Parameters:
    - df (DataFrame): input dataframe.
    - columns (list): list of column names to clean.
    
    Returns:
    - DataFrame: cleaned dataframe.
    """
    for column in columns:
        df[column] = pd.to_numeric(df[column], errors='coerce')  # Convert non-numeric to NaN
        df[column].replace([np.inf, -np.inf], np.nan, inplace=True)  # Replace inf values with NaN
    return df


















# import pandas as pd
# import numpy as np
# import matplotlib.pyplot as plt
# import seaborn as sns

# def handle_missing_values(df, strategy='mean'):
#     """
#     Handle missing values in the dataframe.

#     Parameters:
#     - df (DataFrame): input dataframe with potential missing values.
#     - strategy (str): strategy for handling missing values ('mean', 'median', 'mode').

#     Returns:
#     - DataFrame: dataframe with missing values handled.
#     """
#     for column in df.columns:
#         if df[column].dtype in [np.float64, np.float32, np.int64, np.int32]:
#             if strategy == 'mean':
#                 df[column].fillna(df[column].mean(), inplace=True)
#             elif strategy == 'median':
#                 df[column].fillna(df[column].median(), inplace=True)
#         elif df[column].dtype == 'category':
#             df[column].fillna(df[column].mode()[0], inplace=True)
#     return df

# def remove_duplicates(df, id_column):
#     """
#     Remove duplicate rows based on a specified column.
    
#     Parameters:
#     - df: DataFrame, input data.
#     - id_column: str, column to check for duplicates.
    
#     Returns:
#     - DataFrame: data with duplicates removed.
#     """
#     df = df.drop_duplicates(subset=[id_column])
#     return df

# def check_no_missing_values(df):
#     """
#     Check if there are no missing values in the dataframe.

#     Parameters:
#     - df (DataFrame): input dataframe.

#     Returns:
#     - bool: True if no missing values, else False.
#     """
#     return not df.isnull().values.any()

# def check_no_duplicates(df, id_column):
#     """
#     Check if there are no duplicate rows based on a specified column.

#     Parameters:
#     - df (DataFrame): input dataframe.
#     - id_column (str): column to check for duplicates.

#     Returns:
#     - bool: True if no duplicates, else False.
#     """
#     return df.duplicated(subset=[id_column]).sum() == 0

# def analyze_missing_values(df):
#     """
#     Analyze the missing values in the dataframe.

#     Parameters:
#     - df (DataFrame): input dataframe.

#     Returns:
#     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
#     """
#     missing_values = df.isnull().sum()
#     missing_percentage = (missing_values / len(df)) * 100
#     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
#     return missing_data.sort_values(by='missing_count', ascending=False)

# def compute_correlations(df, target_column):
#     """
#     Compute the correlation of features with the target variable.

#     Parameters:
#     - df (DataFrame): input dataframe.
#     - target_column (str): the target variable.

#     Returns:
#     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
#     """
#     numeric_df = df.select_dtypes(include=[np.number])
#     if target_column not in numeric_df.columns:
#         raise KeyError(f"Target column '{target_column}' not found in the dataframe.")
#     correlations = numeric_df.corr()[target_column].sort_values(ascending=False)
#     return correlations

# def visualize_distributions(df, features):
#     """
#     Visualize the distributions of specified features.

#     Parameters:
#     - df (DataFrame): input dataframe.
#     - features (list): list of feature names to visualize.
#     """
#     for feature in features:
#         plt.figure(figsize=(10, 6))
#         sns.histplot(df[feature].replace([np.inf, -np.inf], np.nan), kde=True)
#         plt.title(f'Distribution of {feature}')
#         plt.show()

# def feature_summary(df):
#     """
#     Generate summary statistics for features.

#     Parameters:
#     - df (DataFrame): input dataframe.

#     Returns:
#     - DataFrame: summary statistics for features.
#     """
#     summary = df.describe(include='all').transpose()
#     return summary

# def visualize_pairwise_relationships(df, features):
#     """
#     Visualize pairwise relationships between specified features.

#     Parameters:
#     - df (DataFrame): input dataframe.
#     - features (list): list of feature names to visualize.
#     """
#     sns.pairplot(df[features])
#     plt.show()

# def analyze_unbalanced_features(df, target_column):
#     """
#     Analyze unbalanced features in relation to the target variable.

#     Parameters:
#     - df (DataFrame): input dataframe.
#     - target_column (str): the target variable.
#     """
#     unbalanced_features = {}
#     for column in df.columns:
#         if df[column].dtype == 'category' or df[column].nunique() <= 10:
#             unbalanced_features[column] = df[column].value_counts(normalize=True)
#     for feature, distribution in unbalanced_features.items():
#         plt.figure(figsize=(10, 6))
#         distribution.plot(kind='bar')
#         plt.title(f'Distribution of {feature}')
#         plt.show()

# def convert_mixed_types(df, dtypes):
#     """
#     Convert mixed types to specified dtypes.
    
#     Parameters:
#     - df (DataFrame): input dataframe.
#     - dtypes (dict): dictionary of column dtypes.
    
#     Returns:
#     - DataFrame: DataFrame with converted dtypes.
#     """
#     for column, dtype in dtypes.items():
#         try:
#             if dtype == 'category':
#                 df[column] = df[column].astype('category')
#             else:
#                 df[column] = pd.to_numeric(df[column], errors='coerce').astype(dtype)
#         except ValueError:
#             print(f"Warning: Could not convert column {column} to {dtype}. Problematic values: {df[column].unique()[:5]}")
#     return df

# def clean_numeric_columns(df, columns):
#     """
#     Clean columns that should be numeric by removing or converting non-numeric values.
    
#     Parameters:
#     - df (DataFrame): input dataframe.
#     - columns (list): list of column names to clean.
    
#     Returns:
#     - DataFrame: cleaned dataframe.
#     """
#     for column in columns:
#         df[column] = pd.to_numeric(df[column], errors='coerce')  # Convert non-numeric to NaN
#     return df







# # import pandas as pd
# # import numpy as np
# # import matplotlib.pyplot as plt
# # import seaborn as sns

# # def handle_missing_values(df, strategy='mean'):
# #     """
# #     Handle missing values in the dataframe using different strategies.

# #     Parameters:
# #     - df (DataFrame): input dataframe with potential missing values.
# #     - strategy (str): strategy for handling missing values. 
# #                       Options: 'mean', 'median', 'mode', 'drop'.

# #     Returns:
# #     - DataFrame: dataframe with missing values handled.
# #     """
# #     if strategy == 'mean':
# #         for column in df.select_dtypes(include=[np.number]).columns:
# #             df[column].fillna(df[column].mean(), inplace=True)
# #     elif strategy == 'median':
# #         for column in df.select_dtypes(include=[np.number]).columns:
# #             df[column].fillna(df[column].median(), inplace=True)
# #     elif strategy == 'mode':
# #         for column in df.select_dtypes(include=['category', 'object']).columns:
# #             df[column].fillna(df[column].mode()[0], inplace=True)
# #     elif strategy == 'drop':
# #         df.dropna(inplace=True)
# #     else:
# #         raise ValueError(f"Unknown strategy: {strategy}")
    
# #     return df

# # def remove_duplicates(df, id_column):
# #     """
# #     Remove duplicate rows based on a specified column.
    
# #     Parameters:
# #     - df (DataFrame): input data.
# #     - id_column (str): column to check for duplicates.
    
# #     Returns:
# #     - DataFrame: data with duplicates removed.
# #     """
# #     df = df.drop_duplicates(subset=[id_column])
# #     return df

# # def check_no_missing_values(df):
# #     """
# #     Check if there are no missing values in the dataframe.

# #     Parameters:
# #     - df (DataFrame): input dataframe.

# #     Returns:
# #     - bool: True if no missing values, else False.
# #     """
# #     return not df.isnull().values.any()

# # def check_no_duplicates(df, id_column):
# #     """
# #     Check if there are no duplicate rows based on a specified column.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - id_column (str): column to check for duplicates.

# #     Returns:
# #     - bool: True if no duplicates, else False.
# #     """
# #     return df.duplicated(subset=[id_column]).sum() == 0

# # def check_value_ranges(df, column_ranges):
# #     """
# #     Check if values in specified columns are within given ranges.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# #     Returns:
# #     - bool: True if all values are within ranges, else False.
# #     """
# #     for column, (min_val, max_val) in column_ranges.items():
# #         if not df[column].between(min_val, max_val).all():
# #             return False
# #     return True

# # def analyze_missing_values(df):
# #     """
# #     Analyze the missing values in the dataframe.

# #     Parameters:
# #     - df (DataFrame): input dataframe.

# #     Returns:
# #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# #     """
# #     missing_values = df.isnull().sum()
# #     missing_percentage = (missing_values / len(df)) * 100
# #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# #     return missing_data.sort_values(by='missing_count', ascending=False)

# # def compute_correlations(df, target_column):
# #     """
# #     Compute the correlation of features with the target variable.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - target_column (str): the target variable.

# #     Returns:
# #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# #     """
# #     numeric_df = df.select_dtypes(include=[np.number])
# #     if target_column not in numeric_df.columns:
# #         raise KeyError(f"Target column '{target_column}' not found in the dataframe.")
# #     correlations = numeric_df.corr()[target_column].sort_values(ascending=False)
# #     return correlations

# # def visualize_distributions(df, features):
# #     """
# #     Visualize the distributions of specified features.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - features (list): list of feature names to visualize.
# #     """
# #     for feature in features:
# #         plt.figure(figsize=(10, 6))
# #         sns.histplot(df[feature], kde=True)
# #         plt.title(f'Distribution of {feature}')
# #         plt.show()

# # def feature_summary(df):
# #     """
# #     Generate a summary for each feature including its type, number of unique values, and number of missing values.

# #     Parameters:
# #     - df (DataFrame): input dataframe.

# #     Returns:
# #     - DataFrame: a summary of features.
# #     """
# #     summary = df.describe(include='all').transpose()
# #     summary['missing_values'] = df.isnull().sum()
# #     summary['unique_values'] = df.nunique()
# #     return summary

# # def visualize_pairwise_relationships(df, features):
# #     """
# #     Visualize pairwise relationships between specified features.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - features (list): list of feature names to visualize.
# #     """
# #     sns.pairplot(df[features])
# #     plt.show()

# # def analyze_unbalanced_features(df, target_column):
# #     """
# #     Analyze unbalanced features in the dataframe.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - target_column (str): the target variable.

# #     Returns:
# #     - None
# #     """
# #     class_counts = df[target_column].value_counts()
# #     print(f"Class distribution for {target_column}:")
# #     print(class_counts)
# #     sns.barplot(x=class_counts.index, y=class_counts.values)
# #     plt.title(f'Class distribution for {target_column}')
# #     plt.show()

# # def convert_mixed_types(df, dtypes):
# #     """
# #     Convert columns with mixed types to appropriate data types.

# #     Parameters:
# #     - df (DataFrame): input dataframe.
# #     - dtypes (dict): dictionary of column dtypes.

# #     Returns:
# #     - DataFrame: DataFrame with enforced dtypes.
# #     """
# #     for column, dtype in dtypes.items():
# #         try:
# #             if dtype == 'category':
# #                 df[column] = df[column].astype('category')
# #             else:
# #                 df[column] = pd.to_numeric(df[column], errors='coerce').astype(dtype)
# #         except ValueError:
# #             print(f"Warning: Could not convert column {column} to {dtype}")
# #     return df














# # # import pandas as pd
# # # import numpy as np
# # # import matplotlib.pyplot as plt
# # # import seaborn as sns

# # # def handle_missing_values(df, strategy='mean'):
# # #     """
# # #     Handle missing values in the dataframe using different strategies.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe with potential missing values.
# # #     - strategy (str): strategy for handling missing values. 
# # #                       Options: 'mean', 'median', 'mode', 'drop'.

# # #     Returns:
# # #     - DataFrame: dataframe with missing values handled.
# # #     """
# # #     if strategy == 'mean':
# # #         for column in df.select_dtypes(include=[np.number]).columns:
# # #             df[column].fillna(df[column].mean(), inplace=True)
# # #     elif strategy == 'median':
# # #         for column in df.select_dtypes(include=[np.number]).columns:
# # #             df[column].fillna(df[column].median(), inplace=True)
# # #     elif strategy == 'mode':
# # #         for column in df.select_dtypes(include=['category', 'object']).columns:
# # #             df[column].fillna(df[column].mode()[0], inplace=True)
# # #     elif strategy == 'drop':
# # #         df.dropna(inplace=True)
# # #     else:
# # #         raise ValueError(f"Unknown strategy: {strategy}")
    
# # #     return df

# # # def remove_duplicates(df, id_column):
# # #     """
# # #     Remove duplicate rows based on a specified column.
    
# # #     Parameters:
# # #     - df (DataFrame): input data.
# # #     - id_column (str): column to check for duplicates.
    
# # #     Returns:
# # #     - DataFrame: data with duplicates removed.
# # #     """
# # #     df = df.drop_duplicates(subset=[id_column])
# # #     return df

# # # def check_no_missing_values(df):
# # #     """
# # #     Check if there are no missing values in the dataframe.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.

# # #     Returns:
# # #     - bool: True if no missing values, else False.
# # #     """
# # #     return not df.isnull().values.any()

# # # def check_no_duplicates(df, id_column):
# # #     """
# # #     Check if there are no duplicate rows based on a specified column.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - id_column (str): column to check for duplicates.

# # #     Returns:
# # #     - bool: True if no duplicates, else False.
# # #     """
# # #     return df.duplicated(subset=[id_column]).sum() == 0

# # # def check_value_ranges(df, column_ranges):
# # #     """
# # #     Check if values in specified columns are within given ranges.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# # #     Returns:
# # #     - bool: True if all values are within ranges, else False.
# # #     """
# # #     for column, (min_val, max_val) in column_ranges.items():
# # #         if not df[column].between(min_val, max_val).all():
# # #             return False
# # #     return True

# # # def analyze_missing_values(df):
# # #     """
# # #     Analyze the missing values in the dataframe.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.

# # #     Returns:
# # #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# # #     """
# # #     missing_values = df.isnull().sum()
# # #     missing_percentage = (missing_values / len(df)) * 100
# # #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# # #     return missing_data.sort_values(by='missing_count', ascending=False)

# # # def compute_correlations(df, target_column):
# # #     """
# # #     Compute the correlation of features with the target variable.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - target_column (str): the target variable.

# # #     Returns:
# # #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# # #     """
# # #     numeric_df = df.select_dtypes(include=[np.number])
# # #     correlations = numeric_df.corr()[target_column].sort_values(ascending=False)
# # #     return correlations

# # # def visualize_distributions(df, features):
# # #     """
# # #     Visualize the distributions of specified features.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - features (list): list of feature names to visualize.
# # #     """
# # #     for feature in features:
# # #         plt.figure(figsize=(10, 6))
# # #         sns.histplot(df[feature], kde=True)
# # #         plt.title(f'Distribution of {feature}')
# # #         plt.show()

# # # def feature_summary(df):
# # #     """
# # #     Generate a summary for each feature including its type, number of unique values, and number of missing values.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.

# # #     Returns:
# # #     - DataFrame: a summary of features.
# # #     """
# # #     summary = df.describe(include='all').transpose()
# # #     summary['missing_values'] = df.isnull().sum()
# # #     summary['unique_values'] = df.nunique()
# # #     return summary

# # # def visualize_pairwise_relationships(df, features):
# # #     """
# # #     Visualize pairwise relationships between specified features.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - features (list): list of feature names to visualize.
# # #     """
# # #     sns.pairplot(df[features])
# # #     plt.show()

# # # def analyze_unbalanced_features(df, target_column):
# # #     """
# # #     Analyze unbalanced features in the dataframe.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - target_column (str): the target variable.

# # #     Returns:
# # #     - None
# # #     """
# # #     class_counts = df[target_column].value_counts()
# # #     print(f"Class distribution for {target_column}:")
# # #     print(class_counts)
# # #     sns.barplot(x=class_counts.index, y=class_counts.values)
# # #     plt.title(f'Class distribution for {target_column}')
# # #     plt.show()

# # # def convert_mixed_types(df, dtypes):
# # #     """
# # #     Convert columns with mixed types to appropriate data types.

# # #     Parameters:
# # #     - df (DataFrame): input dataframe.
# # #     - dtypes (dict): dictionary of column dtypes.

# # #     Returns:
# # #     - DataFrame: DataFrame with enforced dtypes.
# # #     """
# # #     for column, dtype in dtypes.items():
# # #         try:
# # #             if dtype == 'category':
# # #                 df[column] = df[column].astype('category')
# # #             else:
# # #                 df[column] = pd.to_numeric(df[column], errors='coerce').astype(dtype)
# # #         except ValueError:
# # #             print(f"Warning: Could not convert column {column} to {dtype}")
# # #     return df












# # # # import pandas as pd
# # # # import numpy as np
# # # # import matplotlib.pyplot as plt
# # # # import seaborn as sns

# # # # def handle_missing_values(df, strategy='mean'):
# # # #     """
# # # #     Handle missing values in the dataframe using different strategies.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe with potential missing values.
# # # #     - strategy (str): strategy for handling missing values. 
# # # #                       Options: 'mean', 'median', 'mode', 'drop'.

# # # #     Returns:
# # # #     - DataFrame: dataframe with missing values handled.
# # # #     """
# # # #     if strategy == 'mean':
# # # #         for column in df.select_dtypes(include=[np.number]).columns:
# # # #             df[column].fillna(df[column].mean(), inplace=True)
# # # #     elif strategy == 'median':
# # # #         for column in df.select_dtypes(include=[np.number]).columns:
# # # #             df[column].fillna(df[column].median(), inplace=True)
# # # #     elif strategy == 'mode':
# # # #         for column in df.select_dtypes(include=['category', 'object']).columns:
# # # #             df[column].fillna(df[column].mode()[0], inplace=True)
# # # #     elif strategy == 'drop':
# # # #         df.dropna(inplace=True)
# # # #     else:
# # # #         raise ValueError(f"Unknown strategy: {strategy}")
    
# # # #     return df

# # # # def remove_duplicates(df, id_column):
# # # #     """
# # # #     Remove duplicate rows based on a specified column.
    
# # # #     Parameters:
# # # #     - df (DataFrame): input data.
# # # #     - id_column (str): column to check for duplicates.
    
# # # #     Returns:
# # # #     - DataFrame: data with duplicates removed.
# # # #     """
# # # #     df = df.drop_duplicates(subset=[id_column])
# # # #     return df

# # # # def check_no_missing_values(df):
# # # #     """
# # # #     Check if there are no missing values in the dataframe.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.

# # # #     Returns:
# # # #     - bool: True if no missing values, else False.
# # # #     """
# # # #     return not df.isnull().values.any()

# # # # def check_no_duplicates(df, id_column):
# # # #     """
# # # #     Check if there are no duplicate rows based on a specified column.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - id_column (str): column to check for duplicates.

# # # #     Returns:
# # # #     - bool: True if no duplicates, else False.
# # # #     """
# # # #     return df.duplicated(subset=[id_column]).sum() == 0

# # # # def check_value_ranges(df, column_ranges):
# # # #     """
# # # #     Check if values in specified columns are within given ranges.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# # # #     Returns:
# # # #     - bool: True if all values are within ranges, else False.
# # # #     """
# # # #     for column, (min_val, max_val) in column_ranges.items():
# # # #         if not df[column].between(min_val, max_val).all():
# # # #             return False
# # # #     return True

# # # # def analyze_missing_values(df):
# # # #     """
# # # #     Analyze the missing values in the dataframe.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.

# # # #     Returns:
# # # #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# # # #     """
# # # #     missing_values = df.isnull().sum()
# # # #     missing_percentage = (missing_values / len(df)) * 100
# # # #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# # # #     return missing_data.sort_values(by='missing_count', ascending=False)

# # # # def compute_correlations(df, target_column):
# # # #     """
# # # #     Compute the correlation of features with the target variable.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - target_column (str): the target variable.

# # # #     Returns:
# # # #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# # # #     """
# # # #     correlations = df.corr()[target_column].sort_values(ascending=False)
# # # #     return correlations

# # # # def visualize_distributions(df, features):
# # # #     """
# # # #     Visualize the distributions of specified features.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - features (list): list of feature names to visualize.
# # # #     """
# # # #     for feature in features:
# # # #         plt.figure(figsize=(10, 6))
# # # #         sns.histplot(df[feature], kde=True)
# # # #         plt.title(f'Distribution of {feature}')
# # # #         plt.show()

# # # # def feature_summary(df):
# # # #     """
# # # #     Generate a summary for each feature including its type, number of unique values, and number of missing values.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.

# # # #     Returns:
# # # #     - DataFrame: a summary of features.
# # # #     """
# # # #     summary = df.describe(include='all').transpose()
# # # #     summary['missing_values'] = df.isnull().sum()
# # # #     summary['unique_values'] = df.nunique()
# # # #     return summary

# # # # def visualize_pairwise_relationships(df, features):
# # # #     """
# # # #     Visualize pairwise relationships between specified features.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - features (list): list of feature names to visualize.
# # # #     """
# # # #     sns.pairplot(df[features])
# # # #     plt.show()

# # # # def analyze_unbalanced_features(df, target_column):
# # # #     """
# # # #     Analyze unbalanced features in the dataframe.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - target_column (str): the target variable.

# # # #     Returns:
# # # #     - None
# # # #     """
# # # #     class_counts = df[target_column].value_counts()
# # # #     print(f"Class distribution for {target_column}:")
# # # #     print(class_counts)
# # # #     sns.barplot(x=class_counts.index, y=class_counts.values)
# # # #     plt.title(f'Class distribution for {target_column}')
# # # #     plt.show()

# # # # def convert_mixed_types(df, dtypes):
# # # #     """
# # # #     Convert columns with mixed types to appropriate data types.

# # # #     Parameters:
# # # #     - df (DataFrame): input dataframe.
# # # #     - dtypes (dict): dictionary of column dtypes.

# # # #     Returns:
# # # #     - DataFrame: DataFrame with enforced dtypes.
# # # #     """
# # # #     for column, dtype in dtypes.items():
# # # #         try:
# # # #             if dtype == 'category':
# # # #                 df[column] = df[column].astype('category')
# # # #             else:
# # # #                 df[column] = pd.to_numeric(df[column], errors='coerce').astype(dtype)
# # # #         except ValueError:
# # # #             print(f"Warning: Could not convert column {column} to {dtype}")
# # # #     return df



















# # # # # import pandas as pd
# # # # # import numpy as np
# # # # # import matplotlib.pyplot as plt
# # # # # import seaborn as sns

# # # # # def handle_missing_values(df, feature_metadata):
# # # # #     """
# # # # #     Handle missing values in the dataframe.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe with potential missing values.
# # # # #     - feature_metadata (dict): metadata for each feature including missing value strategy.

# # # # #     Returns:
# # # # #     - DataFrame: dataframe with missing values handled.
# # # # #     """
# # # # #     for column, metadata in feature_metadata['features'].items():
# # # # #         strategy = metadata.get('missing_value_strategy', 'none')
# # # # #         if strategy == 'mean':
# # # # #             df[column].fillna(df[column].mean(), inplace=True)
# # # # #         elif strategy == 'median':
# # # # #             df[column].fillna(df[column].median(), inplace=True)
# # # # #         elif strategy == 'mode':
# # # # #             df[column].fillna(df[column].mode()[0], inplace=True)
# # # # #         elif strategy == 'ffill':
# # # # #             df[column].fillna(method='ffill', inplace=True)
# # # # #         elif strategy == 'bfill':
# # # # #             df[column].fillna(method='bfill', inplace=True)
# # # # #         elif strategy == 'drop':
# # # # #             df.dropna(subset=[column], inplace=True)
# # # # #         elif strategy == 'constant':
# # # # #             df[column].fillna(metadata.get('fill_value', 0), inplace=True)
# # # # #         # Add more strategies as needed
# # # # #     return df

# # # # # def remove_duplicates(df, id_column):
# # # # #     """
# # # # #     Remove duplicate rows based on a specified column.
    
# # # # #     Parameters:
# # # # #     - df: DataFrame, input data.
# # # # #     - id_column: str, column to check for duplicates.
    
# # # # #     Returns:
# # # # #     - DataFrame: data with duplicates removed.
# # # # #     """
# # # # #     df = df.drop_duplicates(subset=[id_column])
# # # # #     return df

# # # # # def check_no_missing_values(df):
# # # # #     """
# # # # #     Check if there are no missing values in the dataframe.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.

# # # # #     Returns:
# # # # #     - bool: True if no missing values, else False.
# # # # #     """
# # # # #     return not df.isnull().values.any()

# # # # # def check_no_duplicates(df, id_column):
# # # # #     """
# # # # #     Check if there are no duplicate rows based on a specified column.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - id_column (str): column to check for duplicates.

# # # # #     Returns:
# # # # #     - bool: True if no duplicates, else False.
# # # # #     """
# # # # #     return df.duplicated(subset=[id_column]).sum() == 0

# # # # # def check_value_ranges(df, column_ranges):
# # # # #     """
# # # # #     Check if values in specified columns are within given ranges.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# # # # #     Returns:
# # # # #     - bool: True if all values are within ranges, else False.
# # # # #     """
# # # # #     for column, (min_val, max_val) in column_ranges.items():
# # # # #         if not df[column].between(min_val, max_val).all():
# # # # #             return False
# # # # #     return True

# # # # # def analyze_missing_values(df):
# # # # #     """
# # # # #     Analyze the missing values in the dataframe.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.

# # # # #     Returns:
# # # # #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# # # # #     """
# # # # #     missing_values = df.isnull().sum()
# # # # #     missing_percentage = (missing_values / len(df)) * 100
# # # # #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# # # # #     return missing_data.sort_values(by='missing_count', ascending=False)

# # # # # def compute_correlations(df, target_column):
# # # # #     """
# # # # #     Compute the correlation of features with the target variable.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - target_column (str): the target variable.

# # # # #     Returns:
# # # # #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# # # # #     """
# # # # #     correlations = df.corr()[target_column].sort_values(ascending=False)
# # # # #     return correlations

# # # # # def visualize_distributions(df, features):
# # # # #     """
# # # # #     Visualize the distributions of specified features.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - features (list): list of feature names to visualize.
# # # # #     """
# # # # #     for feature in features:
# # # # #         plt.figure(figsize=(10, 6))
# # # # #         sns.histplot(df[feature], kde=True)
# # # # #         plt.title(f'Distribution of {feature}')
# # # # #         plt.show()

# # # # # def feature_summary(df):
# # # # #     """
# # # # #     Provide a summary of features including data types, number of unique values, and example values.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.

# # # # #     Returns:
# # # # #     - DataFrame: summary of the features.
# # # # #     """
# # # # #     summary = pd.DataFrame({
# # # # #         'data_type': df.dtypes,
# # # # #         'num_unique': df.nunique(),
# # # # #         'example_value': df.iloc[0]
# # # # #     })
# # # # #     return summary

# # # # # def visualize_pairwise_relationships(df, features):
# # # # #     """
# # # # #     Visualize pairwise relationships between specified features.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - features (list): list of feature names to visualize.

# # # # #     Returns:
# # # # #     - None
# # # # #     """
# # # # #     sns.pairplot(df[features])
# # # # #     plt.show()

# # # # # def analyze_unbalanced_features(df, target_column):
# # # # #     """
# # # # #     Analyze unbalanced features with respect to the target column.

# # # # #     Parameters:
# # # # #     - df (DataFrame): input dataframe.
# # # # #     - target_column (str): the target variable.

# # # # #     Returns:
# # # # #     - None
# # # # #     """
# # # # #     unbalanced_features = df[target_column].value_counts()
# # # # #     print(unbalanced_features)
# # # # #     unbalanced_features.plot(kind='bar')
# # # # #     plt.title(f'Distribution of {target_column}')
# # # # #     plt.show()
























# # # # # # import pandas as pd
# # # # # # import numpy as np
# # # # # # import matplotlib.pyplot as plt
# # # # # # import seaborn as sns

# # # # # # def handle_missing_values(df, strategy='mean'):
# # # # # #     """
# # # # # #     Handle missing values in the dataframe.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe with potential missing values.
# # # # # #     - strategy (str): strategy for handling missing values ('mean', 'median', 'mode').

# # # # # #     Returns:
# # # # # #     - DataFrame: dataframe with missing values handled.
# # # # # #     """
# # # # # #     if strategy == 'mean':
# # # # # #         for column in df.select_dtypes(include=[np.number]).columns:
# # # # # #             df[column].fillna(df[column].mean(), inplace=True)
# # # # # #     elif strategy == 'median':
# # # # # #         for column in df.select_dtypes(include=[np.number]).columns:
# # # # # #             df[column].fillna(df[column].median(), inplace=True)
# # # # # #     elif strategy == 'mode':
# # # # # #         for column in df.select_dtypes(include=['category']).columns:
# # # # # #             df[column].fillna(df[column].mode()[0], inplace=True)
# # # # # #     else:
# # # # # #         raise ValueError(f"Unknown strategy: {strategy}")
    
# # # # # #     return df

# # # # # # def remove_duplicates(df, id_column):
# # # # # #     """
# # # # # #     Remove duplicate rows based on a specified column.
    
# # # # # #     Parameters:
# # # # # #     - df: DataFrame, input data.
# # # # # #     - id_column: str, column to check for duplicates.
    
# # # # # #     Returns:
# # # # # #     - DataFrame: data with duplicates removed.
# # # # # #     """
# # # # # #     df = df.drop_duplicates(subset=[id_column])
# # # # # #     return df

# # # # # # def check_no_missing_values(df):
# # # # # #     """
# # # # # #     Check if there are no missing values in the dataframe.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.

# # # # # #     Returns:
# # # # # #     - bool: True if no missing values, else False.
# # # # # #     """
# # # # # #     return not df.isnull().values.any()

# # # # # # def check_no_duplicates(df, id_column):
# # # # # #     """
# # # # # #     Check if there are no duplicate rows based on a specified column.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.
# # # # # #     - id_column (str): column to check for duplicates.

# # # # # #     Returns:
# # # # # #     - bool: True if no duplicates, else False.
# # # # # #     """
# # # # # #     return df.duplicated(subset=[id_column]).sum() == 0

# # # # # # def check_value_ranges(df, column_ranges):
# # # # # #     """
# # # # # #     Check if values in specified columns are within given ranges.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.
# # # # # #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# # # # # #     Returns:
# # # # # #     - bool: True if all values are within ranges, else False.
# # # # # #     """
# # # # # #     for column, (min_val, max_val) in column_ranges.items():
# # # # # #         if not df[column].between(min_val, max_val).all():
# # # # # #             return False
# # # # # #     return True

# # # # # # def analyze_missing_values(df):
# # # # # #     """
# # # # # #     Analyze the missing values in the dataframe.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.

# # # # # #     Returns:
# # # # # #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# # # # # #     """
# # # # # #     missing_values = df.isnull().sum()
# # # # # #     missing_percentage = (missing_values / len(df)) * 100
# # # # # #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# # # # # #     return missing_data.sort_values(by='missing_count', ascending=False)

# # # # # # def compute_correlations(df, target_column):
# # # # # #     """
# # # # # #     Compute the correlation of features with the target variable.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.
# # # # # #     - target_column (str): the target variable.

# # # # # #     Returns:
# # # # # #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# # # # # #     """
# # # # # #     correlations = df.corr()[target_column].sort_values(ascending=False)
# # # # # #     return correlations

# # # # # # def visualize_distributions(df, features):
# # # # # #     """
# # # # # #     Visualize the distributions of specified features.

# # # # # #     Parameters:
# # # # # #     - df (DataFrame): input dataframe.
# # # # # #     - features (list): list of feature names to visualize.
# # # # # #     """
# # # # # #     for feature in features:
# # # # # #         plt.figure(figsize=(10, 6))
# # # # # #         sns.histplot(df[feature], kde=True)
# # # # # #         plt.title(f'Distribution of {feature}')
# # # # # #         plt.show()










# # # # # # # import pandas as pd
# # # # # # # import numpy as np
# # # # # # # import matplotlib.pyplot as plt
# # # # # # # import seaborn as sns

# # # # # # # def handle_missing_values(df):
# # # # # # #     """
# # # # # # #     Handle missing values in the dataframe.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe with potential missing values.

# # # # # # #     Returns:
# # # # # # #     - DataFrame: dataframe with missing values handled.
# # # # # # #     """
# # # # # # #     # Fill missing values with the mean for numeric columns
# # # # # # #     for column in df.select_dtypes(include=[np.number]).columns:
# # # # # # #         df[column].fillna(df[column].mean(), inplace=True)

# # # # # # #     # Fill missing values with the mode for categorical columns
# # # # # # #     for column in df.select_dtypes(include=['category']).columns:
# # # # # # #         df[column].fillna(df[column].mode()[0], inplace=True)
    
# # # # # # #     return df

# # # # # # # def remove_duplicates(df, id_column):
# # # # # # #     """
# # # # # # #     Remove duplicate rows based on a specified column.
    
# # # # # # #     Parameters:
# # # # # # #     - df: DataFrame, input data.
# # # # # # #     - id_column: str, column to check for duplicates.
    
# # # # # # #     Returns:
# # # # # # #     - DataFrame: data with duplicates removed.
# # # # # # #     """
# # # # # # #     df = df.drop_duplicates(subset=[id_column])
# # # # # # #     return df

# # # # # # # def check_no_missing_values(df):
# # # # # # #     """
# # # # # # #     Check if there are no missing values in the dataframe.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.

# # # # # # #     Returns:
# # # # # # #     - bool: True if no missing values, else False.
# # # # # # #     """
# # # # # # #     return not df.isnull().values.any()

# # # # # # # def check_no_duplicates(df, id_column):
# # # # # # #     """
# # # # # # #     Check if there are no duplicate rows based on a specified column.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.
# # # # # # #     - id_column (str): column to check for duplicates.

# # # # # # #     Returns:
# # # # # # #     - bool: True if no duplicates, else False.
# # # # # # #     """
# # # # # # #     return df.duplicated(subset=[id_column]).sum() == 0

# # # # # # # def check_value_ranges(df, column_ranges):
# # # # # # #     """
# # # # # # #     Check if values in specified columns are within given ranges.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.
# # # # # # #     - column_ranges (dict): dictionary where keys are column names and values are tuples (min, max).

# # # # # # #     Returns:
# # # # # # #     - bool: True if all values are within ranges, else False.
# # # # # # #     """
# # # # # # #     for column, (min_val, max_val) in column_ranges.items():
# # # # # # #         if not df[column].between(min_val, max_val).all():
# # # # # # #             return False
# # # # # # #     return True

# # # # # # # import pandas as pd

# # # # # # # def analyze_missing_values(df):
# # # # # # #     """
# # # # # # #     Analyze the missing values in the dataframe.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.

# # # # # # #     Returns:
# # # # # # #     - DataFrame: a dataframe containing the count and percentage of missing values for each feature.
# # # # # # #     """
# # # # # # #     missing_values = df.isnull().sum()
# # # # # # #     missing_percentage = (missing_values / len(df)) * 100
# # # # # # #     missing_data = pd.DataFrame({'missing_count': missing_values, 'missing_percentage': missing_percentage})
# # # # # # #     return missing_data.sort_values(by='missing_count', ascending=False)

# # # # # # # def compute_correlations(df, target_column):
# # # # # # #     """
# # # # # # #     Compute the correlation of features with the target variable.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.
# # # # # # #     - target_column (str): the target variable.

# # # # # # #     Returns:
# # # # # # #     - DataFrame: a dataframe containing the correlation of each feature with the target variable.
# # # # # # #     """
# # # # # # #     correlations = df.corr()[target_column].sort_values(ascending=False)
# # # # # # #     return correlations

# # # # # # # def visualize_distributions(df, features):
# # # # # # #     """
# # # # # # #     Visualize the distributions of specified features.

# # # # # # #     Parameters:
# # # # # # #     - df (DataFrame): input dataframe.
# # # # # # #     - features (list): list of feature names to visualize.
# # # # # # #     """
# # # # # # #     for feature in features:
# # # # # # #         plt.figure(figsize=(10, 6))
# # # # # # #         sns.histplot(df[feature], kde=True)
# # # # # # #         plt.title(f'Distribution of {feature}')
# # # # # # #         plt.show()

